\label{sec:introduction}
Computational science and engineering (CSE) communities develop
complex applications to solve scientific and engineering challenges,
but these communities have a mixed record of using software
engineering best practices. Many codes developed by CSE communities
adopt standard software practices when the size and complexity of an
application becomes too unwieldy to continue without them
\cite{cc2012}. The driving force behind adoption is usually the
realization that without using software engineering practices, the
development, the verification and the maintenance of applications can become
intractable. As more codes cross the threshold into increasing
complexity, software engineering processes are being adopted from
practices derived outside of the scientific and engineering domain.
State-of-the-art for software engineering practices in CSE codes often lags
behind that in the commercial software space
\cite{segal2008developing,basili2008understanding, hochstein2008asc}. 
% \comment{KA NOTE: Do we have any
% reference for this claim? AD: I don't know of one, though this seems
% to be the consensus.  Let's just soften a little then.  I added "often"}
There are many reasons for it: lack of incentives, support and
funding; reward system favors scientific results but not software 
development; many software engineering practices need customization
for use in scientific communities but there is very little
research in the software engineering community targeted to specific
needs of such codes. 

Some software engineering practices have been better accepted 
among developers of scientific codes than others. The ones that are
used quite often include repositories for code version control,
licensing process, regular testing, documentation, release and distribution
policies, and contribution policies \cite{cc2012, carver2012software,
Dubey2014}. Less accepted practices include code-review,
code-deprecation, and adoption of development methodologies such as
Agile \cite{agile}. Software best practices that may be very effective in commercial
software development environments are not always suited for scientific
enviroments partly because of sociology and partly because of technical
challenges. Sociology manifests itself as suspicion of too rigid a
process or not seeing the point of adopting a practice. The
technical challenges arise from the nature of problems being addresssed by
these codes. For example, multiphysics and multicomponents  
codes that run on large High Performance Computing 
(HPC) platforms put a large premium on performance. It is our
experience that good performance is most often achieved by sacrificing
some of the modularity in software architecture
(i.e. \cite{Dubey1999}). Similarly lateral interactions in physics get
in the way of encapsulations (See sections \ref{sec:domain-challenges}
and \ref{sec:institutional-challenges} for details).

This chapter elaborates on the above challenges and how they were
addressed in FLASH and Amanzi, two codes with very  
different develepment timeframe and therefore very different
development paths. FLASH, whose development began in the late 1990's,
is among the first generation of codes that
adopted a software process. This was in the era when the advantages of
software engineering were almost unknown in the scientific
world. Amanzi is from the ``enlightened'' era (by scientific software
standards) where a minimal set of software practices are adopted by
most code projects intending long term use. A study of software
engineering of two codes from different eras of scientific software
development highlight how these practices  and the communities have
evolved.    

FLASH was originally designed for computational
astrophysics. It has been almost continuously 
under production and development since 2000 with three major
revisions. It has exploited an extensible framework to expand its
reach as a community code for over half a dozen scientific
communities. The adoption of software engineering practices has
grown with each version change and expansion of capabilities. The
adopted practices themselves have evolved to meet the needs of the
developers at different stages of development. Amanzi, on the other
hand, started in 2012 and has developed 
from the ground up in C++ using relatively modern software engineering
practices. It still has one major target community, but is also
designed with extensibility as an objective. There are many other
similarities and some differences described later in the chapter.
In particular, we address the issues related to software
architecture and modularization, design of a testing regime,
unique documentation needs and challenges, use of versioning system 
for managing projects, and the tension between intellectual property
management and open science.

%and due to the type of institutions where
%such codes are developed.  
% The challenges in developing scientific and engineering applications range
% from data dependencies, to architectural trade-offs, to the process for their maintenance and
% growth. 
% \comment{KA NOTE: see if you like what I re-wrote in last sentence.}
 
%Agile development methods \cite{}
%tend to have limited usefulness in the CSE lifecycle.
% only a 
%select subset of those have met with success.  (KA NOTE: NEED REF) 
% The degree of adoption and sophistication in using software
% engineering practices varies among teams. Many of the reasons for
% lower penetration of more formal software engineering practices are
% discussed in section \ref{sec:instChallenges}. Even among the widely
% adopted practices, most are modified and customized by the developers
% for their own needs. 
The next few sections outline the challenges that  
are either unique to, or are more dominant in scientific
software than elsewhere. Section \ref{sec:lifecycle} describes the
typical lifecycle of a scientific code, followed by domain specific
technical challenges in section \ref{sec:domain-challenges}. This is
followed by a description in section \ref{sec:institutional-challenges}
of technical and sociologicial challenges posed by the institutions
where such codes are typically developed. Section
\ref{sec:case-studies} describes experiences of FLASH and amanzi
development teams. The last two sections provide some general
observations and additional future considerations for adapting the
codes to the end of Moore's Law.

% For example,
% sometimes modularity and encapsulation principles are challenged by
% the need to tightly couple physics solvers to data structures.
% Scientific codes are designed to explore phenomena that are not very
% well understood, so their verification strategies have  to
