
%\begin{itemize}
%\item resources are rarely available for software infrastructure - carved out of scientific goal oriented funding
\label{sec:instChallenges}
Many adaptations in the software engineering for CSE applicationsdescribed in the previous
section pertained to software design and testing. In particular they
spoke to challenges of modularity, performance and unit-testing because of the
intertwined nature of the problems being tackled by these
codes. However, there are a number of challenges that arise in developing and maintaining CSE codes outside of architectural and performance challenges.  Many challenges are specific to the kind of organizations and the research communities
where these codes are developed. The most crippling and pervasive
challenge faced by CSE codes in general, and multiphysics codes in
particular, funding for software development and maintenance is difficult to attain. 
There is evidence that when software is designed well
it pays huge dividends in scientific productivity from the
miniscule number of projects that secured such funding for software
infrastructure design. (KA NOTE: cite the evidence here. NEED REF) Even in the face of the evidence, it remains difficult to obtain funding for investment in software engineering best practices.  Available funding is most often carved out of scientific goal
oriented projects that have their own priorities and time-line. This
model often ends up short-changing the software engineering.

%\item consumers of the software on short term deadlines
%\item organic growth of codes - difficult to impose structure on existing codes

The scientific output of applications is measured in terms of publications, which in
turn depend upon the data produced by the simulations. Therefore, in a
project driven purely by scientific objectives, the short-term science
goals can lead to compromises on the quality of software
design. Quick-and-dirty often triumphs over long term planning.  (KA NOTE: Do we have a reference or example to cite here?)
The cost of future lost productivity is not appreciated until it is too
late. By the time design deficiencies are realized usually the
software has grown too large to remove the deficiencies in any easy
way.  Software engineering is forcibly imposed on the code, which it
at best a band-aid solution. This is another reason why many of the
software practices are not embraced by the CSE community. 

%\item concepts learned on the job
Another institutional challenge faced developing good software engineering practices for CSE codes is 
training students and staff to use the application properly. Multiphysics codes require a broad range of expertise in
domain science from their developers and software engineering skills is an added
requirement.  Often experts in a domain science who develop CSE codes are not trained in software engineering and many learn skills on
the job through reading, or talking to colleagues. The practices are
applied as they understand them, usually picking only what is of most
importance for their own development.  (KA NOTE: Do we have any reference?) This can be both good and
bad. Good because it sifts out the unnecessary aspects of the SE
practice, and bad because it is not always true that the sifted out
aspects were really not necessary. It just means that the person
adopting the practice did not understand how to use them, or their
importance. 

% \item no replication of expertise and great depth in expertise is
%   needed at times
% \item transient population, minimal institutional support

Institutional challenges also arise from scarcity and stability of
resources. The domain and numerical algorithmic
expertise is rarely replicated in a team developing the multiphysics
CSE application.  Even otherwise, deep expertise in the domain may be
needed to model the phenomenon right, and that kind of expertise is
hard to come by. Then there is the challenge to communicating the
model to the software engineer, if there is one on the team, or to
other members of the team with some other domain expertise. It requires at least a
few developers in the team who can act as interpreters for various
domain expertise and are able to integrate them. Such abilities take a
great deal of time and effort to develop, neither of which are
possible in the academic institutions where these codes are typically
organically grown. The available human resources in these institutions
are post-docs and students who move on, so there is no retention of
institutional knowledge about the code.  A few projects that do see
the need for software professionals struggle to find ways of funding
them or to provide a path to professional growth. (KA NOTE: I think this section could use some examples.)

The above institutional challenges also provide a clue about why any
set software development methodology is hard, and often even
undesirable, to adopt in such projects. For example, the principles
behind the agile manifesto apply, but not all the formalized processes
do.  (KA NOTE: Need to describe what the agile methods are here... because you refer to them later in the paragraph without introducing them.)
These codes are developed by interdisciplinary teams where
interactions and collaborations are preferred over process. The code
development and its use for science go on in parallel, so the
requirements change and there is quick feedback when they do.  For the
same reason, the code needs to be in working condition almost all the
time. However, scarcity of resources does not allow the professional roles in
the agile process to be played out efficiently.  There is no clear
separation between the developer and the client, many developers of
the code are also the scientists who use it for their research. 
Because software development goes hand in hand with research and
exploration of the algorithms it is impossible to do either within
fixed time-frames. This constraint effectively eliminates using
sprints.  The waterfall model is even less useful because it is
impossible to do a full specification ahead of time. The code has to
grow and alter organically as the scientific understanding grows, the
effect of using technologies are digested and requirements change.

The need for deep expertise, and the fact that the developer of a
complex physics module is almost definitely going to leave with
possibly no replacement, documentation of various kind takes on a
crucial role. It becomes necessary to document the algorithm, the
implementation choices, and the range of operation. The general
practice of ``writing code that does not need inline documentation''
does not apply. To an expert in the field, who has comprehensive
understanding of the underlying math, such a code might be accessible
without inline documentation. But to all others, and there are many
who have reasons to look at the code, it would be equivalent to having
equations without accompanying explanation. For longevity and
extensibility, a scientific code must have inline documentation
explaining the implementation logic, and reasons behind the
choices made.   
%\end{itemize}