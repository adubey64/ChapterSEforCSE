
%\begin{itemize}
%\item resources are rarely available for software infrastructure - carved out of scientific goal oriented funding
Many adaptations in the software engineering described in the previous
section pertained to software design and testing. In particular they
spoke to challenges to modularity, performance and unit-testing because of the
intertwined nature of the problems being tackled by these
codes. However, all challenges faced by the CSE codes are not only
because of the nature of problems they solve. Many challenges are
specific to the kind of organizations and the research communities
where the codes are developed. The most crippling and pervasive
challenge faced by CSE codes in general and multiphysics codes in
particular is that they rarely get funding for development of software
infrastructure. There is evidence that when software is designed well
it pays huge dividends in scientific productivity, collected from the
miniscule number of projects that secured such funding for software
infrastructure design. Even with the evidence the scientific
establishment remains unconvinced about the criticality of investment
in software engineering. The funding is carved out of scientific goal
oriented funding which has its own priorities and time line which end
up short-changing the software engineering.

%\item consumers of the software on short term deadlines
%\item organic growth of codes - difficult to impose structure on existing codes

The scientific output is measured in terms of publications which in
turn depend upon the data produced by the simulations. Therefore in a
project driven purely by scientific objectives, the short-term science
goals can lead to compromise on the quality of software
design. Quick-and-dirty often triumphs over long term planning. The
cost of future lost productivity is not appreciated until it is too
late. By the time design deficiencies are realized usually the
software has grown too large to remove the deficiencies in any easy
way.  Software engineering is forcibly imposed on the code, which it
at best a band-aid solution. This is another reason why many of the
software practices are not embraced by the CSE community. 

%\item concepts learned on the job
Another instituitional challenge faced by SE for CSE is the
training. Multiphysics codes require a broad range of expertise in
domain science from their developers, software engineering is an added
requirement. The developers are not trained in SE, many learn them on
the job through reading or talking to colleagues. The practices are
applied as they understand them, usually picking only what is of most
importance for their own development. This can be both good and
bad. Good because it sifts out the unnecessary aspects of the SE
practice, and bad because it is not always true that the sifted out
aspects were really not necessary. It just means that the person
adopting the practice did not understand how to use them, or their
importance. 

% \item no replication of expertise and great depth in expertise is
%   needed at times
% \item transient population, minimal institutional support

Institutional challenges also arise from scarcity of
resources and stability. The domain and numerical algorithmic
expertise is rarely replicated in a team developing the multiphysics
CSE application. Even otherwise, deep expertise in the domain may be
needed to model the phenomenon right, and that kind of expertise is
hard to come by. Then there is the challenge to communicating the
model to the software engineer if there is one on the team, or to
other members of the team with other expertise. It requires at least a
few developers in the team who can act as interpreters for the various
domain expertise and are able to integrate them. Such abilities take a
great deal of time and effort to develop, neither of which are
possible in the academic institutions where these codes are typically
organically grown. The available human resources in these institutions
are post-docs and students who move on, so there is no retention of
institutional knowledge about the code.  A few projects that do see
the need for software professionals struggle to find ways of funding
them or to provide a path to professional growth. 

The above institutional challenges also provide a clue about why any
set software development methodology is hard, and often even
undesirable, to adopt in such projects. For example, the principles
behind the agile manifesto apply, but not all the formalized process
does. These codes are developed by interdisciplinary teams where
interactions and collaborations are preferred over process. The code
development and its use for science go on in parallel, so the
requirements change and there is quick feedback when they do. For the
same reason, the code needs to be in working condition almost all the
time. However, scarcity of resources does not allow the professional roles in
the agile process to be played out efficiently.  There is no clear
separation between the developer and the client, many developers of
hte code are the scientists who use for their research. 
Because software development goes hand in hand with research and
exploration of the algorithms it is impossible to do either within
fixed time-frames. This constraint effectively eliminates using
sprints.  The waterfall model is even less useful because it is
impossible to do a full specification ahead of time. The code has to
grow and alter organically as the scientific understanding grows, the
effect of using technologies are digested and requirements change.

The need for deep expertise, and the fact that the developer of a
complex physics module is almost definitely going to leave with
possibly no replacement, documentation of various kind takes on a
crucial role. It becomes necessary to document the algorithm, the
implementation choices, and the range of operation. The general
practice of ``writing code that does not need inline documentation''
does not apply. To an expert in the field, who has comprehensive
understanding of the underlying math, such a code might be accessible
without inline documentation. But to all others, and there are many
who have reasons to look at the code, it would be equivalent to having
equations without accompanying explanation. For longevity and
extensibility, a scientific code must have inline documentation
explaining the implementation logic, and the reasons behind the
choices made.   
%\end{itemize}