

\subsection{Code Design}
From the outset FLASH was required to have composability because the
simulations of interest needed capabilities in different permutations
and combinations. For example, most simulations needed compressible
hydrodynamics, but with different equations of state. Some needed to
include self-gravity while others did not. An 
obvious solution was to use object-oriented programming model with
common API's and specializations to account for the different
models. However, the physics capabilities were mostly legacy with F77
implementations. Rewriting the code in an object oriented language was
not an option. A compromise was found by exploiting the unix directory
structure for inheritence, where for a code unit the top level
directory defined the API and the subdirectories contained the
multiple alternative implementations of the API.  Meta-information
about the role of the directory level in the object oriented framework
was encoded in a very limited domain-specific language (configuration
DSL). The meta-information also included state and runtime variables
requirements, dependences on other code units etc. A ``setup tool''
parsed this information to configure a consistent ``application''. The
setup tool also interpreted the configuration DSL to implement 
inheritence using the directory structure. For more details about
FLASH's object oriented framework see \cite{Dubey2009, Fryxell2000}.   

FLASH design is aware of the need for separation of concerns and
achieves it by separating the infrastural components
from physics. The abstraction that permits this approach is very
well known in CSE, that of decomposing a physical domain into
rectangular form, and surrounding each of the subdomains with halo
cells copied over from the surrounding neighborin subdomains. To the
physics whole domain is not distinguishable from a sub-domain. 
It is also important not to let any of the  physics own the state
variables. They are owned by the infrastructure, which 
decomposes the domain into blocks. A further separation of concern
takes place within the units handling the infrastructure, that of
isolating the parallel aspects from bulk of the code. Parallel
operations such as ghost cell fill, refluxing or regridding have
minimal interleaving with state update in the blocks from application
of physics operators. To distance the solvers from their parallel
constructs, the required parallel operations provide an API with
corresponding functions implemented as a subunit. The implementation
of numerical algorithms for physics operators is sequential,
interspersed with access to the parallel API as needed. This does
impose bulk synchronous communication model on the code, and may need
to be modified.

Minimization of data movement is achieved by letting the state be
completely owned by the infrastructure modules. The dominant
infrastructure module is the {\em Eulerian} mesh, owned and managed by
the {\em Grid} unit. The physics modules query the {\em Grid} unit
for the bounds and extent of the block they are operating on, and
get a pointer to the physical data. This arrangement works in most
cases, but gets tricky where  the data access pattern does not conform
to the underlying mesh. An example is any physics dealing with
Lagrangian entities (LE's). They need a different data structure, and
the movement of data has nothing in common with the way the data moves
on the mesh. The added difficulty is that the entities do need to
interact with the mesh, so physical proximity of the corresponding
mesh cell is important in distributing the LE's. This is one of the
examples of unavoidable lateral interaction between modules. In order
to advance, LE's need to get some field quantities from the mesh and
then determine their new locations internally. In some applications
they have to apply near- and far-field forces, and in some
applications they have to pass some information along to the mesh. And
after advacing in time they may need to be redistributed. FLASH solves
this conundrum through keeping the LE data structure extremely simple,
and using argument passing by reference in the API's. The LE's are
attached to the block in the mesh that has the nearest cell, an LE
leaves its block when its location no longer overlaps with the
block. Migration to the new block is an independent operation from
everything else that goes on with the LE's In FLASH parlance this is
the Lagrangian framework (see \cite{Dubey2012} for more details). The
combination of {\em Eulerian} and {\em Lagrangian} frameworks that
interoperate well with one another has succeeded in meeting all the
performance critical data management needs of the code so far. 

\subsection{Software Process}
The software process of FLASH has evolved organically with the growth
of the code. For instance, in the first version there was no clear
design document, the second version had a loosely implied design
guidance, whereas the third version documented the whole design
process. The third version also published the developer's guide which
is a straight adaptation from the design document. Because of multiple
developers with different production targets versioning repository was
introduced early in the code life cycle. The repository used has been
SVN since 2003, though its branching system has been used in some very
unorthodox ways to meet peculiar needs of the Flash Center. Unlike
most software projects where branches are kept for somewhat isolated
development purposes, FLASH uses branches also to manage multiple
ongoing production projects. This particular need arose because at a
point there were four different streams of production simulations going
on simulataneously in three different scientific domains. All projects
needed some stable code from the trunk, but also needed some
development flexibility in their own branches. And it was understood
that very little of the code added to the branches will make its way
back into the repository. This would have been easy with the
distributed repositories that have become available relatively
recently, but it is difficult in SVN. This was accomplished by turning
the trunk into essentially a merge area, with a separate {\em
  production} branch becoming the base for forward code merges to the
individual projects. The path was tagged-trunk => production =>
projects => merge into trunk => tag trunk when stabilized. Note that
the production branch was never allowed a backward merge to avoid the
possible inadvertent breaking of code for one project by another one.

\subsection{Policies}