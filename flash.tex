

\subsection{Code Design}
From the outset FLASH was required to have composability because the
simulations of interest needed capabilities in different permutations
and combinations. For example, most simulations needed compressible
hydrodynamics, but with different equations of state. Some needed to
include self-gravity while others did not. An 
obvious solution was to use object-oriented programming model with
common API's and specializations to account for the different
models. However, the physics capabilities were mostly legacy with F77
implementations. Rewriting the code in an object oriented language was
not an option. A compromise was found by exploiting the unix directory
structure for inheritence, where for a code unit the top level
directory defined the API and the subdirectories contained the
multiple alternative implementations of the API.  Meta-information
about the role of the directory level in the object oriented framework
was encoded in a very limited domain-specific language (configuration
DSL). The meta-information also included state and runtime variables
requirements, dependences on other code units etc. A ``setup tool''
parsed this information to configure a consistent ``application''. The
setup tool also interpreted the configuration DSL to implement 
inheritence using the directory structure. For more details about
FLASH's object oriented framework see \cite{Dubey2009, Fryxell2000}.   

FLASH design is aware of the need for separation of concerns and
achieves it by separating the infrastural components
from physics. The abstraction that permits this approach is very
well known in CSE, that of decomposing a physical domain into
rectangular form, and surrounding each of the subdomains with halo
cells copied over from the surrounding neighborin subdomains. To the
physics whole domain is not distinguishable from a sub-domain. 
It is also important not to let any of the  physics own the state
variables. They are owned by the infrastructure, which 
decomposes the domain into blocks. A further separation of concern
takes place within the units handling the infrastructure, that of
isolating the parallel aspects from bulk of the code. Parallel
operations such as ghost cell fill, refluxing or regridding have
minimal interleaving with state update in the blocks from application
of physics operators. To distance the solvers from their parallel
constructs, the required parallel operations provide an API with
corresponding functions implemented as a subunit. The implementation
of numerical algorithms for physics operators is sequential,
interspersed with access to the parallel API as needed. This does
impose bulk synchronous communication model on the code, and may need
to be modified.

Minimization of data movement is achieved by letting the state be
completely owned by the infrastructure modules. The dominant
infrastructure module is the {\em Eulerian} mesh, owned and managed by
the {\em Grid} unit. The physics modules query the {\em Grid} unit
for the bounds and extent of the block they are operating on, and
get a pointer to the physical data. This arrangement works in most
cases, but gets tricky where  the data access pattern does not conform
to the underlying mesh. An example is any physics dealing with
Lagrangian entities (LE's). They need a different data structure, and
the movement of data has nothing in common with the way the data moves
on the mesh. The added difficulty is that the entities do need to
interact with the mesh, so physical proximity of the corresponding
mesh cell is important in distributing the LE's. This is one of the
examples of unavoidable lateral interaction between modules. In order
to advance, LE's need to get some field quantities from the mesh and
then determine their new locations internally. In some applications
they have to apply near- and far-field forces, and in some
applications they have to pass some information along to the mesh. And
after advacing in time they may need to be redistributed. FLASH solves
this conundrum through keeping the LE data structure extremely simple,
and using argument passing by reference in the API's. The LE's are
attached to the block in the mesh that has the nearest cell, an LE
leaves its block when its location no longer overlaps with the
block. Migration to the new block is an independent operation from
everything else that goes on with the LE's In FLASH parlance this is
the Lagrangian framework (see \cite{Dubey2012} for more details). The
combination of {\em Eulerian} and {\em Lagrangian} frameworks that
interoperate well with one another has succeeded in largely meeting the
performance critical data management needs of the code. 

\subsection{Software Process}
The software process of FLASH has evolved organically with the growth
of the code. For instance, in the first version there was no clear
design document, the second version had a loosely implied design
guidance, whereas the third version documented the whole design
process. The third version also published the developer's guide which
is a straight adaptation from the design document. Because of multiple
developers with different production targets versioning repository was
introduced early in the code life cycle. The repository used has been
SVN since 2003, though its branching system has been used in some very
unorthodox ways to meet peculiar needs of the Flash Center. Unlike
most software projects where branches are kept for somewhat isolated
development purposes, FLASH uses branches also to manage multiple
ongoing projects. This particular need arose when there were four
different streams physics capabilities being added to the code. All
projects needed some code from the trunk, but the code being added was
mostly exclusive to the individual project. It was important that the
branches stay more or less in sync with the trunk and that the new
code be tested regularly. This was accomplished by turning the trunk
into essentially a merge area, with a schedule of merge from from
individual branches, and an intermediate branch for forward merge. The
path was tagged-trunk => forward-branch => projects => merge into
trunk => tag trunk when stabilized. Note that the forward branch was
never allowed a backward merge to avoid the possible inadvertent
breaking of code for one project by another one. For the same reason
the project branches never did a forward merge directly from the
trunk. 

Testing is another area where the standard practices do not adequately
meet the needs of the code. Many multiphysics codes have legacy
components in them that are written in early versions of
Fortran. Contrary to popular belief, a great deal of new development
continues in Fortran as well because it still is the best HPC language
in which to express mathematical algorithms. All of solver code in
FLASH is F90, so the general unit test harnesses aren't available for
use. Small scale unit tests can only be devised for infrastructural
code because all the physics has to interact with the mesh. Also,
because regular testing became a part of FLASH development process
long before formal incorporation of software engineering practices in
the process, FLASH's designation of tests only loosely follows the
standard definitions. So a unit test in FLASH can rely on other parts
of the code, as long as the feature being tested is isolated. For
example testing for correct filling of halo cells uses a lot of AMR
code that has little to do with the halo filling, but it is termed
unit test in FLASH parlance because it exclusively tests a single
limited functionality. The dominant form of regular testing is
integration testing, where more than one code  capability is combined to
configure an executable. The results of the run are compared against
pre-approved results to verify that nothing changed. Because of a
large space of possible valid and useful combinations selected of tests
becomes a challenging task. FLASH's methodology for test design and
selection is described in detail in \cite{Dubey2015}, and follows the
matrix method described in chapter \ref{chp:testing}

FLASH's documentation takes a comprehensive approach with having a
user's guide, developer's guide, robodocced API, inline documentation,
and online resources. Each type of documentation serves a different
purpose and is indispensable to the developers and users of the code.  
There are scripts in place that look for violations of coding
standards and documentation requirements. User's guide documents the
mathematical formulation, algorithms used and instructions on using
various code components. The user's guide also includes examples of
relevant applications explaining the use of each code module. The
developer's guide specifies the design principles and coding standards
with an extensive example of the module architecture. Each function in
the API is required to have a robodoc header explaining the
input/output, function and special features of the function. Except
for the third party software, every non-trivial function in the code
is required to have sufficient inline documentation that a non-expert
can understand and maintain the code.

FLASH effectively has two versions of release - internal, which
is close to the agile model, and external, which is no more than twice
a year. The internal release amounts to tagging a stable version in
the repository for the internal users of the code. This is signal to
the users that a forward merge into their production branch is not
going to break the code. The external releases have a more rigorous
process which makes them infrequent. 
\subsection{Policies}