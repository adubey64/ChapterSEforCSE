

\subsection{Code Design}
From the outset FLASH was required to have composability because the
simulations of interest needed capabilities in different permutations
and combinations. For example, most simulations needed compressible
hydrodynamics, but plugging into them were different equations of
state. Some needed to include self-gravity while others did not. An
obvious solution was to use object-oriented programming model with
common API's and specializations to account for the different
models. However, the physics capabilities were mostly legacy with F77
implementations. Rewriting the code in an object oriented language was
not an option. A compromise was found by exploiting the unix directory
structure for inheritence, where for a code unit the top level
directory defined the API and the subdirectories contained the
multiple alternative implementations of the API. Meta-information
about the role of the directory level in the object oriented framework
was encoded in a very limited domain-specific language. The
meta-information also included state and runtime variables
requirements, dependences on other code units etc. A ``setup tool''
parsed this information to configure a consistent ``application''. 
For more details about FLASH's object oriented framework
see \cite{Dubey2009, Fryxell2000}.  

FLASH design is aware of the need for separation of concerns and
achieves it by separating the infrastural components
from physics. The abstraction that permits this approach is very
well known in CSE, that of decomposing a physical domain into
rectangular form, and surrounding each of the subdomains with halo
cells copied over from the surrounding neighborin subdomains. To the
physics view, whole domain is not distinguishable from a sub-domain. 
It is also important not to let any of the  physics own the state
variables. They are owned by the infrastructure, which 
decomposes the domain into blocks. A further separation of concern
takes place within the units handling the infrastructure, that of
isolating the parallel aspects from bulk of the code. Parallel
operations such as ghost cell fill, refluxing or regridding have
minimal interleaving with state update in the blocks from application
of physics operators. To distance the solvers from their parallel
constructs, the required parallel operations provide an API with
corresponding functions implemented as a subunit. The implementation
of numerical algorithms for physics operators is sequential,
interspersed with calls to the parallel API as needed. This does
impose bulk synchronous communication model on the code, and may need
to be modified.


% Another early design choice that has proved its value was to use
% parallel I/O libraries with self-describing data formats. Porting the
% code to new HPC platforms would have become a recurring resource drain
% without this choice. The ability to develop general analysis tools and
% use third party tools has been an added benefit. However, these
% benefits were not obvious in the early years of the code. FLASH had
% adopted the parallel I/O libraries before they had reached maturity or
% were supported on all platforms. I/O was consistently the barrier to
% early access on new HPC platforms because  the libraries did not
% immediately become available. The libraries are now very stable and
% they get on the new platforms in roughly the same time frame as
% compilers do.  At the scale at which FLASH is used for production now,
% any other form of I/O would cause unacceptable delay in scientific
% analysis of the data produced by the simulations.   

% Many architectural elements, such as inheritance, customization, and
% the existence of multiple alternative implementations, have stayed the same
% throughout the evolution of the code. Some others, such as data
% management and scoping and encapsulation of code components, changed
% over time, while several others, such as the formalization of unit
% architecture and the unit testing framework, were introduced
% later. However, the philosophy of the FLASH architecture is
% essentially what was laid down in the early versions
% \citep{Fryxell2000}.

% The most influential design choice made for FLASH3 was to dispense
% with backward compatibility with earlier versions. This choice was
% made easier by the deep changes in PARAMESH and HDF at roughly the
% same time. It led to a three-fold benefit: (1) it was possible to make
% fundamental changes to the structure of the code units and their data
% management, (2) we could re-examine the lateral interactions between
% units dictated by physics in ways that enabled unit encapsulation and
% therefore extensibility, and (3) it permitted pruning of the source tree
% where needed to help unclutter the code infrastructure. 

% FLASH3 also focused on eliminating limitations to extensibility that
% came from  the specifications of the FLASH's mesh being tied very
% closely to those of PARAMESH. For example, all blocks have the same
% number of cells in PARAMESH, therefore, FLASH up to version 2 fixed
% number of cells per block at configuration
% level. Similarly, the order of indices in the solution data arrays
% followed the PARAMESH mode, where field variables were the first index
% in a Fortran 90 array. These assumptions effectively eliminated
% the possibility of using other available AMR packages. 
% With these limitations removed, other block structured AMR packages
% can be considered for inclusion in FLASH. For example, 
% the release of version 4 includes Chombo \citep{Chombo2009} as an
% alternative AMR mesh within FLASH. Several other modifications
% to code architecture and functionality used in FLASH3, 
% such as formalization of the code unit architecture, are described in
% \citet{Dubey2009}.  The architecture of FLASH3 has proved to be robust
% enough that it has not required any major infrastructure revision for
% adding the new capabilities for HEDP and FSI. Even though FLASH4 is a
% major version change, it inherited its architecture and software
% engineering practices from FLASH3. It is only the advent of a major
% shift in hardware architecture that is proving to be a challenge and
% is likely to result in fundamental refactoring of the code
% infrastructure in future.

\subsection{Software Process}
\subsection{Policies}